---
title: Transform
description: Transform request and response data with full type inference
---

The Transform plugin enables per-request transformation of query, body, and response data. All transforms are defined at the inject function level for full type inference.

## Installation

```package-install
@spoosh/plugin-transform
```

## Setup

```typescript
import { Spoosh } from "@spoosh/core";
import { transformPlugin } from "@spoosh/plugin-transform";

const client = new Spoosh<ApiSchema, Error>("/api").use([transformPlugin()]);
```

## Usage

### Request Transforms (injectRead)

Transform request data in options:

```typescript
const posts = injectRead((api) => api("posts").GET({ query: { page: 1 } }), {
  transform: {
    query: (q) => {
      // q is typed based on the endpoint schema
      if (q.category === "all") delete q.category;
      return { ...q, limit: 10 };
    },
  },
});
```

### Response Transforms (injectRead)

Response transforms produce a separate `transformedData` field in `meta` while preserving the original `data`:

```typescript
const posts = injectRead((api) => api("posts").GET(), {
  transform: {
    response: (posts) => ({
      // posts is typed as the endpoint's response type
      count: posts.length,
      hasMore: posts.length >= 10,
      ids: posts.map((p) => p.id),
    }),
  },
});

// posts.data() = Post[] (original response, preserved)
// posts.meta().transformedData = { count: number, hasMore: boolean, ids: number[] } | undefined
```

The `meta().transformedData` type is automatically inferred from your transformer's return type.

### Request Transforms (injectWrite)

Transform request data in trigger options:

```typescript
const createPost = injectWrite((api) => api("posts").POST);

createPost.trigger({
  body: { title: "New Post" },
  transform: {
    body: (b) => ({
      ...b,
      createdAt: Date.now(),
      version: "2.0",
    }),
  },
});
```

### Response Transforms (injectWrite)

Just like `injectRead`, response transforms for `injectWrite` produce a separate `transformedData` field in `meta`:

```typescript
const createPost = injectWrite((api) => api("posts").POST);

const response = await createPost.trigger({
  body: { title: "New Post" },
  transform: {
    response: (post) => ({
      // post is typed as the endpoint's response type
      success: true,
      postId: post.id,
      createdAt: new Date(post.timestamp),
    }),
  },
});

// After trigger completes:
// createPost.data() = Post (original response, preserved)
// createPost.meta().transformedData = { success: boolean, postId: number, createdAt: Date } | undefined
```

<Callout type="warning">
**TypeScript Limitation**: Due to TypeScript's limitations with dynamic trigger options, `meta().transformedData` is typed as `never` in the result. You'll need to use type assertion to access it:

```typescript
const createPost = injectWrite((api) => api("posts").POST);

// Type assertion required
const typed = createPost.meta().transformedData as
  | { success: boolean; postId: number }
  | undefined;
```

Alternatively, extract it from the trigger response:

```typescript
const createPost = injectWrite((api) => api("posts").POST);

const response = await createPost.trigger({
  body: { title: "New Post" },
  transform: {
    response: (post) => ({ success: true, postId: post.id }),
  },
});

// Access from response
const result = response.data; // Post
// meta().transformedData is available in the state after trigger completes
```

</Callout>

## Transform Types

### Query Transform

Transform query parameters before the request:

```typescript
const users = injectRead(
  (api) => api("users").GET({ query: { status: "all", page: 1 } }),
  {
    transform: {
      query: (query) => {
        // Remove "all" status filter
        if (query.status === "all") {
          const { status, ...rest } = query;
          return rest;
        }
        return query;
      },
    },
  }
);
```

### Body Transform

Transform JSON body before the request:

```typescript
const createPost = injectWrite((api) => api("posts").POST);

createPost.trigger({
  body: { title: "Hello" },
  transform: {
    body: (body) => ({
      ...body,
      timestamp: Date.now(),
      clientVersion: "1.0.0",
    }),
  },
});
```

### Response Transform

Transform and analyze response data:

```typescript
const analytics = injectRead((api) => api("analytics").GET(), {
  transform: {
    response: (analytics) => ({
      totalViews: analytics.reduce((sum, a) => sum + a.views, 0),
      averageEngagement:
        analytics.reduce((sum, a) => sum + a.engagement, 0) / analytics.length,
      topPerformer: analytics.sort((a, b) => b.views - a.views)[0],
    }),
  },
});

// analytics.data() = original analytics array
// analytics.meta().transformedData = computed summary with totals and top performer
```

## Async Transforms

All transform functions support async operations:

```typescript
const posts = injectRead((api) => api("posts").GET(), {
  transform: {
    query: async (query) => {
      const token = await getAuthToken();
      return { ...query, token };
    },
  },
});
```

## Removing Data

Return `undefined` to remove the data entirely:

```typescript
const results = injectRead(
  (api) => api("search").GET({ query: { q: "", filters: {} } }),
  {
    transform: {
      query: (query) => {
        // Remove query if search term is empty
        if (!query.q?.trim()) return undefined;
        return query;
      },
    },
  }
);
```

## Immutability

Data is deep-cloned before transformation, so you can safely mutate:

```typescript
transform: {
  query: (query) => {
    // Safe to mutate - original data is not affected
    delete query.internalField;
    query.normalized = true;
    return query;
  },
}
```

## Multiple Transforms

Apply multiple transforms in a single request:

```typescript
const posts = injectRead((api) => api("posts").GET({ query: { page: 1 } }), {
  transform: {
    query: (q) => ({ ...q, limit: 20 }),
    response: (posts) => ({
      count: posts.length,
      titles: posts.map((p) => p.title),
    }),
  },
});
```

## Type Inference

The transform plugin provides full type inference:

```typescript
// Response type is inferred from endpoint (injectRead)
const users = injectRead((api) => api("users").GET(), {
  transform: {
    response: (users) => {
      // 'users' is typed as User[]
      return {
        activeCount: users.filter((u) => u.active).length,
        admins: users.filter((u) => u.role === "admin"),
      };
    },
  },
});

// users.meta().transformedData is typed as:
// { activeCount: number; admins: User[] } | undefined
```

### TypeScript Limitations with injectWrite

For `injectWrite`, there is a TypeScript limitation where `meta().transformedData` is inferred as `never` in the result due to dynamic trigger options:

```typescript
const createPost = injectWrite((api) => api("posts").POST);

// meta().transformedData is typed as 'never' here because TypeScript cannot infer
// the type from dynamic trigger options passed later

// ❌ Type error: transformedData is never
console.log(createPost.meta().transformedData.success);

// ✅ Use type assertion
const typed = createPost.meta().transformedData as
  | { success: boolean; postId: number }
  | undefined;
console.log(typed?.success);
```

This is a known TypeScript limitation with higher-order function type inference. For `injectRead`, the options are passed at function creation time, allowing full type inference. For `injectWrite`, options are passed to `trigger` dynamically, which breaks TypeScript's ability to infer the result type.

**Workaround**: Define your transformed type separately:

```typescript
type TransformedPost = {
  success: boolean;
  postId: number;
  createdAt: Date;
};

const createPost = injectWrite((api) => api("posts").POST);

// Use type assertion
const transformed = createPost.meta().transformedData as
  | TransformedPost
  | undefined;
```

## Use Cases

### Compute Derived Data

```typescript
const orders = injectRead((api) => api("orders").GET(), {
  transform: {
    response: (orders) => ({
      total: orders.reduce((sum, o) => sum + o.amount, 0),
      averageOrder:
        orders.reduce((sum, o) => sum + o.amount, 0) / orders.length,
      pendingCount: orders.filter((o) => o.status === "pending").length,
    }),
  },
});
```

### Filter Empty Query Params

```typescript
const results = injectRead((api) => api("search").GET({ query: filters }), {
  transform: {
    query: (query) =>
      Object.fromEntries(
        Object.entries(query).filter(
          ([_, v]) => v !== undefined && v !== null && v !== ""
        )
      ),
  },
});
```

### Add Request Metadata

```typescript
const createEvent = injectWrite((api) => api("events").POST);

createEvent.trigger({
  body: eventData,
  transform: {
    body: (body) => ({
      ...body,
      clientTimestamp: Date.now(),
      sessionId: getSessionId(),
      userAgent: navigator.userAgent,
    }),
  },
});
```
